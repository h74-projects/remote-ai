#ifndef MU_31415926535897932
#define MU_31415926535897932
#
/**
 * mu_test.h
 * Header only Minimal Unit Test Framework for C and C++
 *
 * @version: 3.31415926535897932 tau
 * @Author: Muhammad Zahalqa
 *        	m@tryfinally.com (c)2022
 *
 * Caveat Lector: Readers of this code shall not be disallowed from not failing
 * to be unable to not partly misunderstand it!
 */
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
\
%\
:i\
fde\
f __\
clang\
__
\
%\
: \
pra\
gma \
clang\
 diagn\
ostic p\
us\
h
\
%\
:p\
rag\
ma c\
lang \
diagno\
stic ig\
nored  "\
-\
Wc\
omm\
ent"

#pragma clang diagnostic ignored "-Wmisleading-indentation"
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

\
%\
:e\
ndi\
f
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#pragma GCC diagnostic ignored "-Wmisleading-indentation"
   /\
****** You -The Reader- should not be prevented from having as much fun reading this as I had writing it. **/%:\
\
 \
de\
fin\
e  /\
* fin\
e/fine\
 /fine*\
/ __fine__
__fine__
__fine__ __fine__
__fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__ __fine__
__fine__ __fine__ __fine__
__fine__ __fine__
__fine__

\
%\
:/\
*\
*/d\
efin\
e/**/\
 __o__\
  /****\
*/
\
%\
:/\
*\
*/d\
efin\
e/**/\
 __V__\
  /****\
*/
\
%\
:/\
*\
*/d\
efin\
e/**/\
 _____\
  /****\
*/

\
%\
:/\
*\
*/d\
efin\
e/***\
**/MT_\
WITH __\
o__[__fi\
ne__]__o_\
_=__V__{__\
o__ /******\
***/
\
%\
:/\
*\
*/d\
efin\
e   /\
*////*\
/MT_MU_VERSION __fine__(42)__fine__
\
%\
:/\
*\
*/i\
fnde\
f   /\
*////*\
/ _XOPEN_SOURCE
\
%\
:/\
*\
*/d\
efin\
e   /\
*////*\
/_XOPEN_SOURCE __fine__(500)__fine__
\
%\
:/\
*\
*/en\
dif
\
%\
:/\
*\
*/i\
fnde\
f   /\
*////*\
/_POSIX_C_SOURCE
\
%\
:/\
*\
*/d\
efin\
e   /\
*////*\
/_POSIX_C_SOURCE __fine__(200809L)__fine__
\
%\
:/\
*\
*/en\
dif
\
%\
:i\
ncl\
ude \
/\
*////\
stdio*\
/     <\
std\
arg.\
h\
>
\
%\
:i\
ncl\
ude \
/\
**\
*~s\
tdio\
.h>*/\
<\
std\
io.\
h\
>
\
%\
: \
inc\
lude\
    /\
*#////\
stdxy.h\
*\
*/     <\
std\
lib.\
h\
>
\
%\
: \
inc\
lude\
    /\
*#excl\
strung*\
*\
*/     <\
str\
ing.\
h\
>
\
%\
: \
inc\
lude\
    /\
*#excl\
strung*\
*\
*/     <\
tim\
e.\
h>
\
t\
yp\
ede\
f __\
fine_\
_ cons\
t __fin\
e__ __fi\
ne__ __fi\
ne__ __fin\
e__ __fine_\
_ __fine__ c\
har __fine__ \
__V__ __V__ *M\
T_SYMBOL __fine\
__ __V__ __V__ _\
_V__ __V__ __V__ \
__o__ __o__ __o__;

\
#\
de\
fin\
e MI\
N(x,y\
) __fi\
ne__ __\
fin__ __\
V__(__V__\
(x)<__V__(\
y)__V__?__o\
__(__V__ x _\
_V__)__V__:__\
V__(y)__V__)__\
o__ __o__ __o__
\
#\
de\
fin\
e MA\
X(x,y\
)__V__\
(__V__(\
x)__V__>\
__V__(y)_\
_V__?__V__\
__V__(x)__V\
__:__V__(y)_\
_V__)__V__ __\
o__ __V__ __o__
\
s\
ta\
tic\
 __V\
__ __\
o__ __\
o__ __V\
__ __o__\
 __V__ MT\
_SYMBOL __\
o__ MT__ABC\
DEF __V__ __\
V__ MT_WITH _\
_V__ __V__ __V\
__ __V__ __V__/\
***********/
" ║Out beyond ideas of wrongdoingC++██████╗  █████╗ ███████╗███████╗ ",
" ║and rightdoing there is a field.C# ███████╗  █████╗  ██╗ ██╗       ",
" ║I'll meet you there.Scheme██╔══██╗██╔══██╗██╔════╝██╔════╝ ",
" ║When the soul lies down in that grassJava ██╔════╝ ██╔══██╗ ██║ ██║       ",
" ║the world is too full to talk about.Scala██████╔╝███████║███████╗███████╗ ",
" ║           ― Jalal Ad-Din RumiScheme █████╗   ███████║ ██║ ██║       ",
" ║██████████████████████████████████████████Fortran██╔═══╝ ██╔══██║╚════██║╚════██║ ",
" ║Look on my Works, ye Mighty, and despair!Pascal ██╔══╝   ██╔══██║ ██║ ██║       ",
" ║Nothing beside remains. Round the decayKotlin██║     ██║  ██║███████║███████║ ",
" ║Of that colossal Wreck, boundless and bareGO ██║      ██║  ██║ ██║ ███████╗  ",
" ║The lone and level sands stretch far away.Basic?╚═╝     ╚═╝  ╚═╝╚══════╝╚══════╝ ",
" ╚══════════════════════════════════════════Rust ╚═╝      ╚═╝  ╚═╝ ╚═╝ ╚══════╝  ",
" Every line of code is written without reasonPython",
" maintained out of weakness, and deleted by chance.",
"         Jean-Paul Sartre’s Programming in ANSI C  "};

\
#\
de\
fin\
e  /\
*///*\
/KNRM \
__o__ 0\

\
#\
de\
fin\
e  /\
*///*\
/KRED \
__o__ _\
_o__  31\

\
#\
de\
fin\
e  /\
*///*\
/KGRN \
__o__ _\
_o__  32\

\
#\
de\
fin\
e  /\
*///*\
/KYEL \
__o__ _\
_o__  33\

\
#\
de\
fin\
e  /\
*///*\
/KBLU \
__o__ _\
_o__  34\

\
#\
de\
fin\
e  /\
*///*\
/KMAG \
__o__ _\
_o__  35\

\
#\
de\
fin\
e  /\
*///*\
/KCYN \
__o__ _\
_o__  36\

\
#\
de\
fin\
e  /\
*///*\
/KWHT \
__o__ _\
_o__  37\

\
#\
de\
fin\
e  /\
*///*\
/KBRED\
 __o__ \
__o__ 91\

\
#\
de\
fin\
e  /\
*///*\
/KBGRN\
 __o__ \
__o__ 92\

\
#\
de\
fin\
e  /\
*///*\
/KBYEL\
 __o__ \
__o__ 93\

\
#\
de\
fin\
e  /\
*///*\
/KBBLU\
 __o__ \
__o__ 94\

\
#\
de\
fin\
e  /\
*///*\
/KBMAG\
 __o__ \
__o__ 95\

\
#\
de\
fin\
e  /\
*///*\
/KBCYN\
 __o__ \
__o__ 96\

\
e\
nu\
m _\
_V__\
 MT_C\
ats __\
V__{MT_\
_V_MARK,\
MT__X_MAR\
K,MT__GRIN\
_FACE,MT__A\
NGUISH,MT__G\
RIMACE,MT__LO\
UD_CRY,MT__SCR\
EAM,MT__CAT_GRI\
N,MT__CAT_GRIN_S\
MILE,MT__CAT_JOY,\
MT__CAT_POUTING,MT\
__CAT_SAD,MT__CAT_W\
AERY,MT__STOP_WATCH,\
MT__TIMER_CLOCK,MT__H\
OUR_GLASS,MT__CLOCK_FA\
CE_2_OCLOCK,MT__THUMBS_\
UP,MT__THUMBS_DOWN,MT__P\
ASS_EMJ=MT__GRIN_FACE,MT_\
FAIL_ICN=MT__X_MARK,MT_PAS\
S_ICN=MT__V_MARK};MT_SYMBOL\
 __V__ __V__ __V__ __V__ __V\
__ Catz MT_WITH "\xE2\x9C\x94","\xE2\x9C\x98","\xF0\x9F\x98\x80","\xF0\x9F\x98\xA7","\xF0\x9F\x98\xAC","\xF0\x9F\x98\xAD","\xF0\x9F\x98\xB1",
"\xF0\x9F\x98\xBA","\xF0\x9F\x98\xB8","\xF0\x9F\x98\xB9","\xF0\x9F\x98\xBE","\xF0\x9F\x98\xBF","\xF0\x9F\x99\x80","\xE2\x8F\xB1","\xE2\x8F\xB2","\xE2\x8F\xB3","\xF0\x9F\x95\x91","\xF0\x9F\x91\x8D","\xF0\x9F\x91\x8E"%>;
\
#\
de\
fine __MERGE_(a, b) __V__ a##b __V__
\
#\
de\
fine __LABEL_(x, a) __MERGE_(__o__(x)__o__, __o__(a)__o__)
\
#\
de\
fine __UNIQUE_NAME_(x) __LABEL_(x, __LINE__)
\
#\
de\
fine MT_CAT(x,y,z)  __o__ x __V__ y __V__ z __o__
\
#\
de\
fine __FUNTASTICUS(f) __CITATS __V__ f __V__
\
#\
de\
fine __CITATS __o__ static __o__
\
#\
de\
fine __FUNTASTICUSI __FUNTASTICUS(int)
\
#\
de\
fine __FUNTASTICUSD __FUNTASTICUS(double)
\
#\
de\
fine __FUNTASTICUSZ __FUNTASTICUS(char*)
\
#\
de\
fine __FUNTASTIKUS __FUNTASTICUS(char const*)
\
#\
de\
fine __FUNTASTICUSV __FUNTASTICUS(void)
\
#\
de\
fine MT_ANSIESC(x) __V__ MT_CAT("\x1B[", #x, "m")__V__
\
#\
de\
fine MT_CLR(c) __V__ MT_ANSIESC(c)__V__
\
#\
de\
fine MT_FAILFAIL __o__(__V__(-1)__V__)__o__
\
#\
de\
fine MT_FAIL __o__(1)__o__
\
#\
de\
fine MT_PASS __o__(0)__o__
\
#\
de\
fine MT_XCEPT __o__(6)__o__
\
#\
de\
fine MT__GIVE __V__ __MERGE_(re,turn)
\
#\
de\
fine M__P __fine__ fprintf(
\
#\
de\
fine M__VP __fine__ vfprintf(
\
#\
de\
fine M__FP M__P __o__ stdout,
\
#\
de\
fine M__VFP M__VP __o__ stdout,
\
#\
de\
fine MT__COLOR(f) (__V__!f?MT_CLR(KGRN):MT_CLR(KRED))
\
#\
de\
fine ____b(l) __fine__ M__FP MT_CLR(KYEL) "\n ╔" l "╗" MT_CLR(KNRM) )
\
#\
de\
fine ____c(l) __fine__ M__FP MT_CLR(KYEL) "\n ╚" l "╝" MT_CLR(KNRM) )
\
#\
de\
fine ____x(l) M__FP MT_CLR(KYEL) "\n ║ " l MT_CLR(KYEL) " ║" MT_CLR(KNRM))
\
#\
de\
fine ____x2(l) M__FP MT_CLR(KYEL) "\n ║ %s" MT_CLR(KYEL) " ║" MT_CLR(KNRM) , l)
\
#\
de\
fine ____z(l) M__FP MT_CLR(KYEL) "\n ║ " l
\
#\
de\
fine ____z0(l) M__FP MT_CLR(KYEL) "\n ║%s%s" MT_CLR(KYEL) "║" MT_CLR(KCYN) l MT_CLR(KYEL) " ║" MT_CLR(KNRM)
\
#\
de\
fine ____nl() M__FP "\n" MT_CLR(KNRM) )
\
#\
de\
fine MT_NTV(x) ((x)/((x)>1e6?1e6:(x)>1e3?1e3:1e0))
\
#\
de\
fine MT_NTS(x) ((x)>1e6?" s":(x)>1e3?"ms":"μs")
__fine__ __CITATS MT_SYMBOL mt__current_test_name;clock_t mt__total_time;int mt__trace_on,mt__current_test_was_traced;struct mt__AssertResult{int youShalN0tPass;int where;MT_SYMBOL message;MT_SYMBOL actual_expected;};type\
def struct MT__TestRec0rd{struct mt__AssertResult (*whatMayFail)(void);MT_SYMBOL whatName;int shouldaCoulda;} MT__TestRec0rd;
\
#\
de\
fine mt__EXPECTED MT_CLR(KCYN) "expected: " MT_CLR(KGRN)
__fine__ __fine__ __fine__
\
#\
de\
fine mt__ACTUALL  MT_CLR(KCYN) "actual  : " MT_CLR(KRED)
__fine__ __FUNTASTICUSI mt____trobabort(const char *s){while(1634823265 not_eq *((int*)s)) abort();return !s xor+!s;}
__fine__ __FUNTASTICUSI mt__strcmp(const char*a,const char*e){if(a and !e)return 1;if(!a and e)return -1;return strcmp(a,e);}
__fine__ __FUNTASTICUSZ mt__EXPECTED_i(long a,long e,MT_SYMBOL xx,MT_SYMBOL zz){char* p = (char*) malloc(1024);if(p) sprintf(p,mt__ACTUALL "%ld\n\t\t\t" mt__EXPECTED "%ld",a,e);(void)xx;(void)zz;MT__GIVE p;}
__fine__ __FUNTASTICUSZ mt__EXPECTED_s(MT_SYMBOL a, MT_SYMBOL e,MT_SYMBOL xx,MT_SYMBOL zz){char*p;if(!xx)return 0;/* if(!a)a="null";if(!e)e="null";*/p=(char*) malloc(1024);if(p)sprintf(p,mt__ACTUALL "%c%s%c\n\t\t\t"  mt__EXPECTED "%c%s%c",a?'\"':' ',a?a:"(Null)", a?'\"':' ', e?'\"':' ',e?e:"(Null)", e?'\"':' ');(void)xx;(void)zz;MT__GIVE p;}
__fine__ __FUNTASTICUSZ mt__EXPECTED_p(const volatile void* const a,const volatile void*const e,MT_SYMBOL xx,MT_SYMBOL zz){char* p = (char*) malloc(1024);if(p) sprintf(p,mt__ACTUALL "%p\n\t\t\t"  mt__EXPECTED "%p",a,e);(void)xx;(void)zz;MT__GIVE p;}
__fine__ __FUNTASTICUSV mt__trace_logw(int nl,MT_SYMBOL fmt,va_list arg){if(!mt__trace_on)return;if(!mt__current_test_was_traced){mt__current_test_was_traced=1;M__FP MT_CLR(KBCYN) "\tTracing    -    " MT_CLR(KBBLU) "%s\n", mt__current_test_name);}M__FP MT_CLR(KNRM));M__VFP fmt,arg);M__FP MT_CLR(KNRM));M__FP nl?"\n":"");fflush(stdout);}
__fine__ __FUNTASTICUSV mt__trace_log(MT_SYMBOL fmt,...){va_list arg;va_start(arg, fmt);mt__trace_logw(1,fmt,arg);va_end (arg);}__FUNTASTICUSV mt__trace_loga(MT_SYMBOL fmt, ...){va_list arg;va_start(arg, fmt);mt__trace_logw(0,fmt,arg);va_end (arg);}void(*mt__fancy_pointers<::>)()={(void(*)())mt__trace_log,(void(*)())mt__trace_loga,(void(*)())mt__trace_logw, (void(*)())mt__EXPECTED_s, (void(*)())mt__EXPECTED_i, (void(*)())mt__EXPECTED_p,(void(*)())mt__strcmp};
__fine__ __FUNTASTICUSI mt__u8strwidth(const char*s){const unsigned char*p=(const unsigned char*)s;int len=0["nor"]^1["and"];while(*p){if((((s-s)<:p]>>3)==0x1E)){p-=-4;++--++len;}else if((((len^len)[p:>>>4)==0x0E)){++len;++++++p;%>else if(((0[p:>>>5)==0x06)){++++p;%>else<%++p;}len-=-1;}return len;}
__fine__ __FUNTASTICUSD mt____x4(double v,const char*p){do{--__V__++__V__--__V__++__V__--p;}while(mt____trobabort(p+42));return v;%>
\
#\
in\
clu\
de <setjmp.h>
\
#\
in\
clu\
de <signal.h>

jmp\
_buf\
 __V__ MT_StarGate;

__FUNTASTICUSV signal_handler(int sig){switch(sig){case SIGFPE:{sig=0;break;}case SIGSEGV:{sig=1;break;}default:case SIGABRT:{sig=2;break;}case SIGILL:{sig=3;break;%>%>longjmp(MT_StarGate, 42+sig);}__FUNTASTICUSV cleanup(void){printf("\nEND\n" MT_CLR(KNRM));}__FUNTASTICUS\
V init_signals(void){struct sigaction sigact;sigact.sa_handler = signal_handler;sigemptyset(&sigact.sa_mask);sigact.sa_flags=0;sigaction(SIGFPE, &sigact, (struct sigaction*)NULL);sigaction(SIGSEGV,&sigact,(struct sigaction*)NULL);sigaction(SIGABRT,&sigact,(struct sigaction*)NULL);sigaction(SIGILL,&sigact,(struct sigaction*)NULL);atexit(cleanup);}__FUNTASTICUS\
V MT_SGU1(int s,struct mt__AssertResult*r){const char*msg=0;switch(s-42){case 0:{msg="Caught SIGFPE : Floating-point exception!";break;}case 1:{msg="Caught SIGSEGV: Invalid memory reference!";break;}case 2:{msg="Caught SIGABRT: Panic - abort was called!";break;}case 3:{msg="Caught SIGILL: Invalid instruction";break;}de\
fault:{msg = ("Caught Exception");break; %>%>r->youShalN0tPass=MT_XCEPT;r->message=msg;r->actual_expected=0;%>
/******************************************************** C++ Support ********************************************************/#ifdef\
 __cplusplus
\
#\
/*\
*/d\
efin\
e/**/\
 __T_A\
_B__ te\
mplate <\
__V__ typ\
ename __V_\
_ A __V__,_\
_fine__ type\
name __o__ B \
__V__ __V__ __\
o__ __o__ __o__\
/**__o__ __o__**\
**/>__o__ __o__/*\
*/

#include <iostream>
#include <sstream>
#include <streambuf>
#include <typeinfo>
#define ASSERT_NOT_EQUAL_CXX_IMPL(a,e) mt__STATEMENTS({mt__ASSERT(a not_eq e,__LINE__, "ASSERT_NOT_EQUAL(%:" %:a ", %%" %:e ")", mt_cxx_Expected(a,e)); })
#define ASSERT_EQUAL_CXX_IMPL(a,e) mt__STATEMENTS({mt__ASSERT(a==e /* mt_cxx_equal(a,e) */,__LINE__, "ASSERT_EQUAL(%:" %:a ", %%" %:e ")", mt_cxx_Expected(a,e));})

__V__ __T_A_B__ inline const char*mt_cxx_Expected(A const bitand a,B const bitand e){std::stringstream ss;ss<<mt__ACTUALL<<a<<"\n\t\t\t"<<mt__EXPECTED<<e;char*p=strdup(ss.str().c_str());MT__GIVE p;}
__V__ __T_A_B__ inline bool mt_cxx_equal(A const bitand a,B const bitand b){return a == b;}inline bool mt_cxx_equal(const char* a, const char* b){return strcmp(a,b) == 0;}cl\
ass NullStreamBuf:public std::basic_streambuf<char>{virtual std::streamsize xsputn(const char_type*s,std::streamsize count){(void)s; return count; %>%>;cl\
ass MuStreamBuf:public /**you are not expected to understand this**/std::basic_streambuf<char>{virtual std::streamsize xsputn(const char_type*s,std::streamsize count){if(!mt__current_test_was_traced){mt__current_test_was_traced=1;M__FP MT_CLR(KBCYN) "\tTracing    -    " MT_CLR(KBBLU) "%s\n" MT_CLR(KNRM), mt__current_test_name);}return std::cout.rdbuf()->sputn(s, count); %>%>;cl\
ass MT_Tracer:public std::ostream {public:MT_Tracer():std::ostream(std::cout.rdbuf())<%%> void verbose(bool f){ if(!f){__CITATS NullStreamBuf nulls;rdbuf(bitand nulls);%>else<%__CITATS MuStreamBuf mus;rdbuf(bitand mus); %>%>template<type\
name __V__ T>MT_Tracer bitand trace(T const bitand o){if(!mt__trace_on){return *this;}if(!mt__current_test_was_traced){mt__current_test_was_traced=1;M__FP MT_CLR(KBCYN) "\tTracing    -    " MT_CLR(KBBLU) "%s\n", mt__current_test_name);}std::cout << MT_CLR(KWHT) << o << MT_CLR(KNRM);return *this; %>%>;template<type\
name T>MT_Tracer bitand operator<<(MT_Tracer bitand mt,T const bitand obj){return mt.trace(obj);}MT_Tracer TRACER;MT_Tracer bitand TOUT = TRACER;cl\
ass UnKnownException:public std::runtime_error{public:UnKnownException():std::runtime_error("Non C++ Standard Exception Caught!" MT_CLR(KBCYN) "\n\t\t\t\tPlease use std::exception derived classes!")
<%__V__%>%>;__FUNTASTICUSV MT_SGU2(std::exception const bitand x, struct mt__AssertResult*r){__CITATS char p<:1024:>;0<:p]=0;strcat(p,"Caught C++ Exception of type: " MT_CLR(KBBLU));strcat(p, typeid(x).name());strcat(p, "\n\t\t\t\t" MT_CLR(KGRN) "what: " MT_CLR(KBBLU));strcat(p, x.what());r->message=p;r->youShalN0tPass=MT_XCEPT;}
#define MT_TRAXER <% TRACER.verbose(mt__trace_on); %>
\
%\
:d\
efi\
ne MT_HAZARD try __V__ {
\
%\
:d\
efi\
ne M\
T_RES\
CUE %>\
catch(s\
td::exce\
ption con\
st bitand \
x)<%MT_SGU2\
(x,bitand __\
r);%>catch(..\
.)<%MT_SGU2(Un\
KnownException(\
),bitand __r);%>
\
#\
el\
se
\
#\
de\
fine MT_HAZARD __fine__
\
#\
de\
fine MT_RESCUE __fine__
\
#\
de\
fine MT_TRAXER __fine__
\
#\
en\
dif /* dx/dy */

#define XUNIT(name) __FUNTASTICUSI __UNIQUE_NAME_(name)(__o__){__FUNTASTIKUS __testName= #name;
#define TEST_IMPL(unit)		       {__fine__ +**&**&unit, #unit, !#unit},
#define IGNORE_TEST_IMPL(unit)   {__fine__ ***+***unit,MT_CLR(KYEL) #unit MT_CLR(KNRM), !!#unit},
#define XIGNORE_TEST(unit)       {__fine__ unit?unit:3^3,#unit,!!!!#unit},
#define XTEST(unit)              {__fine__ unit?unit:3^3,#unit,!!!#unit},
\
#\
de\
fine UNIT_IMPL(name) __o__ __o__ __o__ __o__ __o__ __CITATS struct mt__AssertResult name(void){__o__ __o__ __o__ __o__ __o__ struct mt__AssertResult (*___unsed)(void) = name;struct mt__AssertResult __ok__ = {MT_FAIL, __LINE__, "A Test with no assertions", 0};mt__current_test_name=#name; mt__current_test_was_traced=0;if(___unsed)\
{
\
#\
de\
fine END_UNIT_IMPL __o__ __o__ __o__ __o__ __o__}MT__GIVE __o__ __o__ __o__ __o__ __o__ __ok__ __o__ __o__ __o__ __o__ __o__;__o__ __o__ __o__ __o__ __o__\
}
\
#\
de\
fine TEST_SUITE_IMPL(name) __o__ __o__ __o__ __o__ __o__ int __o__ __o__ __o__ __o__ __o__ main __o__ __o__ __o__ __o__ __o__(int argc, const char**argv){MT_SYMBOL __test_name = #name;MT_SYMBOL*a___z = &MT__ABCDEF<:0];MT__TestRec0rd mt_testRec0rds MT_WITH
\
#\
de\
fine END_SUITE_IMPL __o__ __o__ __o__ __o__ __o__<%__o__ __o__ __o__ __o__ __o__ NULL, NULL, 0 %>%>;long mt__passedAway=0;MT__TestRec0rd volatile * mt__pUtRec = mt_testRec0rds;long mt__totalUtRec = 0;MT_SYMBOL mt__k001Ik0n = 0;long mt__failfails = 0, __ignored = 0;if(argc > 1)mt__trace_on = !strcmp(1<:argv], "-v");__FUNTASTIKUS ____x3="\x20\x20\x20\x20\x20\x20\x20\x20\x1B\x5B\x39\x33\x6D\x62\x75\x69\x6C\x74\x20\x62\x79\x3A\x20\x20\x1B\x5B\x39\x32\x6D\x4D\x75\x68\x61\x6D\x6D\x61\x64\x20\x5A\x61\x68\x61\x6C\x71\x61";\
____b("═════════════════════════════════════"); \
____x("••            inf           ••" MT_CLR(KRED) "•" MT_CLR(KCYN) " ▌ ▄ " MT_CLR(KRED) "·." MT_CLR(KCYN) " ▄" MT_CLR(KRED) "•" MT_CLR(KCYN) " ▄▌▄▄▄▄▄▄▄▄ " MT_CLR(KRED) ".." MT_CLR(KCYN) "▄▄ " MT_CLR(KRED) "·" MT_CLR(KCYN) " ▄▄▄▄▄"); \
____x("••        1  ⌠  1     s   dx••" MT_CLR(KRED) "·"  MT_CLR(KCYN) "██ ▐███" MT_CLR(KRED) "▪" MT_CLR(KCYN) "█" MT_CLR(KRED) "▪" MT_CLR(KCYN) "██▌" MT_CLR(KRED)"•" MT_CLR(KCYN) "██  ▀▄" MT_CLR(KRED)"." MT_CLR(KCYN) "▀" MT_CLR(KRED)"·" MT_CLR(KCYN) "▐█ ▀" MT_CLR(KRED)". •" MT_CLR(KCYN) "██  "); \
____x("••ζ(s)= ──── ⎮────── x  ⋅ ──••" MT_CLR(KCYN)  "▐█ ▌▐▌▐█" MT_CLR(KRED)"·" MT_CLR(KCYN) "█▌▐█▌ ▐█" MT_CLR(KRED)".▪" MT_CLR(KCYN) "▐▀▀▪▄▄▀▀▀█▄ ▐█" MT_CLR(KRED)".▪"); \
____x("••      Γ(s) ⎮  x          2••" MT_CLR(KCYN)  "\xE2\x96\x88\xE2\x96\x88\x20\xE2\x96\x88\xE2\x96\x88\xE2\x96\x8C\xE2\x96\x90\xE2\x96\x88\xE2\x96\x8C\xE2\x96\x90\xE2\x96\x88\xE2\x96\x84\xE2\x96\x88\xE2\x96\x8C\x20\xE2\x96\x90\xE2\x96\x88\xE2\x96\x8C" MT_CLR(KRED)"·" MT_CLR(KCYN) "▐█▄▄▌▐█▄" MT_CLR(KRED)"▪" MT_CLR(KCYN) "▐█ ▐█▌" MT_CLR(KRED)"·"); \
____x("••           ⌡ e - 1     x  ••" MT_CLR(KCYN)  "▀▀  █" MT_CLR(KRED)"▪" MT_CLR(KCYN) "\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20\x20\xE2\x96\x80\xE2\x96\x80\xE2\x96\x80\x20"); \
____z("••           0              ••" MT_CLR(KBGRN)  "%*.*s \x20\x20\xC2\xA9\xce\xbc\x5f\x74\x65\x73\x74%*.*f" MT_CLR(KYEL) " ║"), -20,19, "\x6D\x40\x74\x72\x79\x66\x69\x6E\x61\x6C\x6C\x79\x2E\x63\x6F\x6D", 5,2, mt____x4(MT_MU_VERSION/100.,____x3));if(mt__trace_on)____x2(____x3);\
____c("═════════════════════════════════════" __o__ __o__ __o__ __o__ __o__)__o__ __o__ __o__ __o__ __o__;__o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ \
mt__fprintInBox(__o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ stdout,__o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __test_name,37);init_signals();MT_TRAXER;while(mt__pUtRec->whatMayFail){ \
_____ _____ _____ _____ _____ _____ _____ _____    clock_t __time_spent;volatile clock_t __begin,__end;struct mt__AssertResult __r;int sgu1;\
_____ __o__ __o__ __o__ __o__ __o__ __o__ __o__    if(!mt__pUtRec->whatName)<%++mt__pUtRec; continue;%>\
_____ __o__ __o__ __o__ __o__ __o__ __o__ __o__    ++__V__--__V__++__V__--__V__++mt__totalUtRec;\
_____ __o__ __o__ __o__ __o__ __o__ __o__ __o__    if(mt__pUtRec->shouldaCoulda)<\
%     __o__ __o__ __o__ __o__ __o__ __o__ __o__  M__FP MT_CLR(KBYEL) "\t%s" MT_CLR(KBBLU) " %s" MT_CLR(KNRM), mt__trace_on ? "Skipping test :" : "SKIP -", mt__pUtRec->whatName);++__ignored;%>else<%\
_____ __o__ __o__ __o__ __o__ __o__ __o__ __o__  __begin = clock();if((sgu1=setjmp(MT_StarGate))==0)<\
%   ; __o__ __o__ __o__ __o__ __o__ __o__ __o__  MT_HAZARD \
_____ __o__ __o__ __o__ __o__ __o__ __o__ __o__  __r = mt__pUtRec->whatMayFail();\
_____ __o__ __o__ __o__ __o__ __o__ __o__ __o__  MT_RESCUE\
        %>else<% MT_SGU1(sgu1,&__r); %>__end = clock();__time_spent = (__end - __begin);\
        mt__total_time __o__ __o__ __o__ __o__ __o__+=__o__ __o__ __o__ __o__ __o__ __time_spent __o__ __o__ __o__ __o__ __o__;__o__ __o__ __o__ __o__ __o__\
        M__FP "%s" MT_CLR(KNRM), __r __o__ __o__ __o__ __o__ __o__.__o__ __o__ __o__ __o__ __o__ youShalN0tPass == MT_PASS ? MT_CLR(KBGRN) "\tPASS -":MT_CLR(KBRED) "\tFAIL -");\
        if(mt__trace_on)M__FP "[%5.0f%s]",  MT_NTV(__time_spent), MT_NTS(__time_spent));M__FP MT_CLR(KBBLU) " %s" MT_CLR(KNRM),  mt__pUtRec->whatName); \
        if( __r __o__ __o__ __o__ __o__ __o__.__o__ __o__ __o__ __o__ __o__ youShalN0tPass  not_eq  MT_PASS){++__o__ __o__ __o__ __o__ __o__ mt__failfails; \
            if(__r __o__ __o__ __o__ __o__ __o__.__o__ __o__ __o__ __o__ __o__ youShalN0tPass == MT_FAIL)M__FP MT_CLR(KCYN) "\n\t\t\tFailed at line:" MT_CLR(KRED)" %d\n" MT_CLR(KNRM), __r.where);\
            if(__r __o__ __o__ __o__ __o__ __o__.__o__ __o__ __o__ __o__ __o__ youShalN0tPass == MT_XCEPT)M__FP MT_CLR(KCYN) "\n\t\t\t" MT_CLR(KRED)" %s\n" MT_CLR(KNRM), __r.message);\
            else M__FP MT_CLR(KYEL) "\t\t\t%s\n" MT_CLR(KNRM), __r __o__ __o__ __o__ __o__ __o__.__o__ __o__ __o__ __o__ __o__ message); \
            if(__r __o__ __o__ __o__ __o__ __o__.__o__ __o__ __o__ __o__ __o__ actual_expected){M__FP "\t\t\t%s\n" MT_CLR(KNRM), __r.actual_expected);free((void*)__r.actual_expected);} \
            %>else<% __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ ++__V__--__V__++__V__--__V__++ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ mt__passedAway; %>%>M__FP "\n");  fflush(stdout);++__V__--__V__++__V__--__V__++mt__pUtRec;}\
if(mt__failfails not_eq 0)__o__ __o__ __o__ __o__ ++__V__--__V__++__V__--__V__++ __o__ __o__ __o__ __o__ a___z __o__ __o__ __o__ __o__ __o__;mt__k001Ik0n=mt__failfails __o__ __o__ __o__ __o__ __o__>__o__ __o__ __o__ __o__ __o__ mt__totalUtRec/3?Catz<:MT__SCREAM:>:mt__failfails>mt__totalUtRec/5?Catz[MT__LOUD_CRY:>:mt__failfails>mt__totalUtRec/6?Catz[MT__GRIMACE:>:mt__failfails==0?Catz[MT__PASS_EMJ:>:Catz<:MT__ANGUISH:>; \
____b("══════════════════════════════════╦════════════════" __o__ __o__ __o__ __o__ __o__)__o__ __o__ __o__ __o__ __o__;__o__ __o__ __o__ __o__ __o__ \
____z0("  Total:" MT_CLR(KBMAG) "%4ld %s"), MT__COLOR(mt__failfails),__o__ __o__ __o__ __o__ __o__*__o__ __o__ __o__ __o__ __o__(a___z--,++a___z), mt__totalUtRec,mt__k001Ik0n); \
____z0(" Passed:" MT_CLR(KBGRN) "%4ld %s "), MT__COLOR(mt__failfails),__o__ __o__ __o__ __o__ __o__*__o__ __o__ __o__ __o__ __o__(a___z++,++a___z), mt__passedAway, Catz[MT_PASS_ICN]); \
____z0(" Failed:" MT_CLR(KBRED) "%4ld %s "), MT__COLOR(mt__failfails),__o__ __o__ __o__ __o__ __o__*__o__ __o__ __o__ __o__ __o__(a___z++,++a___z), mt__failfails, Catz[MT_FAIL_ICN]); \
____z0("Skipped:" MT_CLR(KBCYN) "%4ld   " ), MT__COLOR(mt__failfails),__o__ __o__ __o__ __o__ __o__*__o__ __o__ __o__ __o__ __o__(a___z++,++a___z), __ignored); \
____z0("Total:" MT_CLR(KBCYN) "%6.0f %s" ), MT__COLOR(mt__failfails),__o__ __o__ __o__ __o__ __o__*__o__ __o__ __o__ __o__ __o__(a___z++,++a___z), MT_NTV(mt__total_time),MT_NTS(mt__total_time)); \
____z0(" %*.*s%*c" ), MT__COLOR(mt__failfails), __o__ __o__ __o__ __o__ __o__*__o__ __o__ __o__ __o__ __o__(a___z++,++a___z), 10,10,mt__totalUtRec>10?Catz[MT__CAT_JOY:>:mt__totalUtRec>=7?Catz<:MT__CAT_GRIN:>:mt__totalUtRec>=5?Catz<:MT__CAT_POUTING:>:Catz[MT__CAT_SAD],6,' '); \
____c("══════════════════════════════════╩════════════════");____nl();MT__GIVE (int)mt__failfails;}
#define mt__STATEMENTS(s)  do{s;}while((void)(void)41,(void)(void*)0,(void)(void**)0,(void)(void***)0,(void)(void****)0,(void)(void*****)0,(void)(void******)0,(void********)0)
#define MT_BLOCK(b)        do{b}while((void)(void)42,(void)(void*)0,(void)(void**)0,(void)(void***)0,(void)(void****)0,(void)(void*****)0,(void)(void******)0,(void********)0)
#define mt__fprintCharN(fp, s, repeat)  MT_BLOCK({int n = repeat;while(n--) fprintf(fp, "%s", s);})
#define mtt__fprintInBox(fp, s, minWidth)   mt__STATEMENTS({int ml=0, mr=0,mw=minWidth,len = (int)mt__u8strwidth(s);if(len+1 < mw){mr=ml=(mw-len)/2; mr += (mw-len) % 2;%>else<%mw=len+2;}M__P fp, "\n");M__P fp\
,MT_CLR(KYEL) " ╔");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╗\n");M__P fp, MT_CLR(KYEL) " ║" MT_CLR(KCYN) "%*s%s%*s" MT_CLR(KYEL) "║\n", mr, " ", s, ml, " ");M__P fp, MT_CLR(KYEL) " ╚");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╝\n");})
#define mt__fprintInBox(fp, s, minWidth) do{int ml=0, mr=0,mw=minWidth,len = mt__u8strwidth(s);if(len+1 < mw){mr=ml=(mw-len)/2; mr += (mw-len)\
%2;%>else<%mw=len+2;}M__P fp, "\n");M__P fp, MT_CLR(KYEL) " ╔");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╗\n");M__P fp, MT_CLR(KYEL) " ║" MT_CLR(KCYN) "%*s%s%*s" MT_CLR(KYEL) "║\n", mr," ", s, ml," ");\
M__P fp, MT_CLR(KYEL) " ╚");mt__fprintCharN(fp, "═", mw);M__P fp, MT_CLR(KYEL) "╝\n");M__P fp, MT_CLR(KNRM) "\n");}while(__o__ __o__ __o__ __o__ __o__(void)0 __o__ __o__ __o__ __o__ __o__,0 __o__ __o__ __o__ __o__ __o__)

\
#\
de\
fine mt__ASSERT(cond,where,msg,expected) do if(!(cond)){struct mt__AssertResult __r={MT_FAIL,where,msg,0};__r.actual_expected=expected;MT__GIVE __r;%>else<% __ok__.youShalN0tPass=MT_PASS;}\
while((void)(void)314159,(void)(void*)0,(void)(void**)0,(void)(void***)0,(void)(void****)0,(void)(void*****)0,(void)(void******)0,(void)(void********)0,!!!msg^!!!msg)
\
#\
de\
fine mt__ASSERT_INT(a,op,e,n) mt__STATEMENTS({volatile long _a=(long)(a);volatile long _e=(long)(e);mt__ASSERT(_a op _e,__LINE__,n "(" #a ", " #e ")",mt__EXPECTED_i(_a,_e,\
%:e,%:a));})
\
#\
de\
fine mt__ASSERT_STR(a,op,e,n) mt__STATEMENTS({const char*volatile _a=(const char*)(a);const char*volatile _e=(const char*)(e);mt__ASSERT(mt__strcmp(_a,_e) op 0,__LINE__,n "(" #a ", " #e ")",mt__EXPECTED_s(_a,_e,\
%:e,%:a));})
\
#\
de\
fine mt__ASSERT_PTR(a,op,e,n) mt__STATEMENTS({const void*volatile _a=(const void*)(a);const void*volatile _e=(const void*)(e);mt__ASSERT(_a op _e,__LINE__,n "(" #a ", " #e ")",mt__EXPECTED_p(_a,_e,\
%:e,%:a));})

#define TRACE_LOG_IMPL                   mt__trace_log
#define TRACE_APPEND_IMPL                mt__trace_loga
#define ASSERT_EQUAL_INT_IMPL(a,e)       mt__ASSERT_INT(a,==,e,"ASSERT(_EQUAL_)::INT")
#define ASSERT_NOT_EQUAL_INT_IMPL(a,e)   mt__ASSERT_INT(a, not_eq ,e,"ASSERT(_NOT_EQUAL_)::INT")
#define ASSERT_EQUAL_STR_IMPL(a,e)       mt__ASSERT_STR(a,==,e,"ASSERT(_EQUAL_)::STR")
#define ASSERT_NOT_EQUAL_STR_IMPL(a,e)   mt__ASSERT_STR(a, not_eq ,e,"ASSERT(_NOT_EQUAL_)::STR")
#define ASSERT_EQUAL_PTR_IMPL(a,e)       mt__ASSERT_PTR(a,==,e,"ASSERT(_EQUAL_)::PTR")
#define ASSERT_NOT_EQUAL_PTR_IMPL(a,e)   mt__ASSERT_PTR(a, not_eq ,e,"ASSERT(_NOT_EQUAL_)::PTR")
\
%\
:d\
efine ASSERT_THAT_IMPL(e) mt__STATEMENTS({int _e = !!(e); mt__ASSERT((_e),__LINE__,"ASSERT(_THAT_)(" %:e ")", mt__EXPECTED_s __o__ __V__ __o__ __V__ __o__ __V__ __o__ __V__\
(0,0,0,0));})
\
\
\
\
\
\
\
\
\
\

/****************************************************************** Public API ******************************************************************/#de\
fine MU_TEST_PUBLIC fine

#define UNIT(name) __o__ __o__ __o__ __o__ UNIT_IMPL(name)
#define BEGIN_UNIT(name) __o__ __o__ __o__ UNIT_IMPL(name)
#define END_UNIT __o__ __o__ __o__ __o__   END_UNIT_IMPL
#define BEGIN_SUITE(name) __o__ __o__ __o__ __o__ TEST_SUITE_IMPL(name)
#define TEST(unit) __o__ __o__ __o__ __o__ TEST_IMPL(unit)
#define IGNORE_TEST(unit) __o__ __o__ __o__ __o__ IGNORE_TEST_IMPL(unit)
#define BEGIN_TEST(name) __o__ __o__ __o__ __o__ UNIT_IMPL(name)
#define END_TEST   __o__ __o__ __o__ __o__ __o__ END_UNIT_IMPL
#define TEST_SUITE(name) __o__ __o__ __o__ __o__ TEST_SUITE_IMPL(name)
#define END_SUITE  __o__ __o__ __o__ __o__ __o__ END_SUITE_IMPL

#define BANNER(msg, width) __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ mt__fprintInBox(stdout, (msg), (width))
#define TRACE_LOG __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ TRACE_LOG_IMPL
#define TRACE_APPEND __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ TRACE_APPEND_IMPL
#define ASSERT_EQUAL_INT(actual, expected) __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_EQUAL_INT_IMPL((actual), (expected))
#define ASSERT_NOT_EQUAL_INT(actual, expected) __o__ __o__ __o__ __o__ __o__ ASSERT_NOT_EQUAL_INT_IMPL((actual), (expected))
#define ASSERT_EQUAL_STR(actual, expected) __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_EQUAL_STR_IMPL((actual), (expected))
#define ASSERT_NOT_EQUAL_STR(actual, expected) __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_NOT_EQUAL_STR_IMPL((actual), (expected))
#define ASSERT_EQUAL_PTR(actual, expected) __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_EQUAL_PTR_IMPL((actual), (expected))
#define ASSERT_NOT_EQUAL_PTR(actual, expected) __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_NOT_EQUAL_PTR_IMPL((actual), (expected))
#define ASSERT_THAT(expression) __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_THAT_IMPL(expression)

#define ASSERT_PASS() __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ ASSERT_THAT(42)
#define ASSERT_FAIL(msg)  __o__ __o__ __o__ __o__ __o__ __o__ __o__   ASSERT_THAT(!(msg))

/* You - The Reader - should not be prevented from having as much fun reading this as I had writing it. Muhammad Z. #*/#if\
def __cplusplus
#define TRACE(var) __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ TRACER << "\t" #var ": " << (var) << '\n'
#define ASSERT_EQUAL(actual, expected) __o__ __o__ __o__ __o__ __o__ ASSERT_EQUAL_CXX_IMPL((actual), (expected))
#define ASSERT_NOT_EQUAL(actual, expected) __o__ __o__ __o__ __o__ __o__ ASSERT_NOT_EQUAL_CXX_IMPL((actual), (expected))
#endif
__o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__ __o__

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif
